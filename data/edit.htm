<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    
    <script type="module" src="/static/main.js?COMMIT_HASH"></script>
  	<!-- script src="/static/ace.js?v=1.9.6"></script -->
  	<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.15.0/ace.min.js"></script>
  	<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.15.0/theme-monokai.js"></script>
  	<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.15.0/mode-html.js"></script>

    <title>openHASP</title>
    <link rel="stylesheet" href="/static/vars.css?COMMIT_HASH"/>
    <link rel="stylesheet" href="/static/style.css?COMMIT_HASH"/>
    <link rel="icon" href="/static/logo.svg?COMMIT_HASH" type="image/svg+xml">
    
    <link href="https://fonts.cdnfonts.com/css/jetbrains-mono" rel="stylesheet">
    <link href="https://fonts.cdnfonts.com/css/source-code-pro" rel="stylesheet">
    
    <style>
      ul {
        list-style-type: none;
        padding-left: 20px;
      }
    </style>

  </head>
  <body v-cloak v-scope @vue:mounted="mounted" onLoad="prepare()">

  	<div class="container__editor" onmousedown="hidectx()">
    	<div class="container__left">
  	     <div id=tree>
          <div class="sub_div">

          </div>
        </div>
    	</div>
    	<div class="resizer" id="dragMe"></div>
    	<div class="container__right">
    		<div class="toolbar">
          <input type="file" id="upload" name="upload" multiple hidden onChange="doUpload()">
    			<span class="left"><button id="home">Home</button><button onClick="_('upload').click()">Upload</button><button id="save">Save</button></span>
    			<div class="right">
          <input id="page" type="number" min="1" max="12" class="number">
          <button id="load">Reload Pages</button>
          <button id="init">Clear Pages</button>
          </div>
    			<span class="left"><button id="cut">Cut</button><button id="copy">Copy</button><button id="paste">Paste</button></span>
    			<span id="name">config.jsonl</span>
    			<span class="left"><button id="undo">Undo</button><button id="redo">Redo</button></span>
    			<span class="left"><select id="font">
    				<option>JetBrains Mono</option>
    				<option selected>Source Code Pro</option>
    			<input id="fontsize" type="number" step="any" min="9" max="40" value="12"></input></span>
    		</div>
    		<div id="editor" class="container__bottom"></div>
    		<div id="preview" class="container__bottom"><img id="pic" src="/static/logo.svg?COMMIT_HASH"/></div>
        <iframe id=download-frame></iframe>
    	</div>
    	<div id="ctx" onmousedown="event.stopPropagation()">
        <ul>
          <li><span class="icon file"></span>New File</li>
          <li><span class="icon edit"></span>Edit</li>
          <li><span class="icon eye"></span>Preview</li>
          <li><span class="icon download"></span>Download</li>
          <li><span class="icon trash"></span>Delete</li>
        </ul>
      </div>
    </div>

    <script>
  		function _(id) { return document.getElementById(id)	}
      function hidectx() { _("ctx").style.display = "none"; }
    	
			// https://www.kirupa.com/html5/detect_whether_font_is_installed.htm
			function doesFontExist(fontName) {
				// creating our in-memory Canvas element where the magic happens
				var canvas = document.createElement("canvas");
				var context = canvas.getContext("2d");
				
				// the text whose final pixel size I want to measure
				var text = "abcdefghijklmnopqrstuvwxyz0123456789";
				
				// specifying the baseline font
				context.font = "72px monospace";
				
				// checking the size of the baseline text
				var baselineSize = context.measureText(text).width;
				
				// specifying the font whose existence we want to check
				context.font = "72px '" + fontName + "', monospace";
				
				// checking the size of the font we want to check
				var newSize = context.measureText(text).width;
				
				// removing the Canvas element we created
				canvas = null;
				
				//
				// If the size of the two text instances is the same, the font does not exist because it is being rendered
				// using the default sans-serif font
				//
				if (newSize == baselineSize) {
					return false;
				} else {
					return true;
				}
			}

			function createEditor(id, path, lang, theme, mime) {
				function texttype(file) {
					let mode = "plain_text",
						ext = /(?:\.([^.]+))?$/.exec(file)[1];
					if (undefined !== typeof ext) {
						switch (ext) {
							// case "txt":
							// 
							//     return "plain";
							case "htm":
							case "html":
								return "html";
							case "js":
								return "javascript";
							case "cmd":
							case "json":
							case "jsonl":
								return "json";
							// case "c":
							// case "cpp":
							//     return "c_cpp";
							case "css":
							case "svg":
							case "xml":
							// case "scss":
							// case "php":
								return ext;
						}
					}
					return mode
				}
				undefined === path && (path = "/"), undefined === lang && (lang = texttype(path)), undefined === mime && (mime = "text/" + lang);

				/* Load optional modules from the CDN */
				const paths = ["basePath","modePath","themePath"];
				paths.forEach((p) => {
					ace.config.set(p, "https://cdnjs.cloudflare.com/ajax/libs/ace/1.15.0");
				});

				var editor = ace.edit(id, {
						useWorker: false,
						wrap: true,
						indentedSoftWrap: false,
						showPrintMargin: false,
						highlightGutterLine: true,
						setUseSoftTabs: true,
						tabSize: 2
					});
				editor.setFontSize(parseFloat(getComputedStyle(document.documentElement).fontSize));
				editor.on("focus", function() { _("ctx").style.display = "none" });

				if (undefined === theme) theme = (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) ? "monokai" : "textmate";

				function j() {
					4 == req.readyState && 200 != req.status && alert("ERROR[" + req.status + "]: " + req.responseText)
				}

				var saveBtn = _("save"),
				    undoBtn = _("undo"),
				    redoBtn = _("redo"),
				    cutBtn  = _("cut"),
				    copyBtn = _("copy"),
				    pasteBtn= _("paste"),
				    fontSel = _("font"),
				    // themeSel = _("theme"),
				    sizeSel = _("fontsize"),
				    isShown = _(id).display !== "none";
				sizeSel.value = parseFloat(editor.getFontSize()).toFixed(1);

				function addFont(item, index) {
					if (doesFontExist(item)) {
						var option = document.createElement("option");
						option.text = item;
						fontSel.add(option); 
					}
				}

				fontSel.onchange = function() { editor.setOption("fontFamily", "'" + fontSel.value + "',monospace") }
				// themeSel.onchange = function() { editor.setTheme("ace/theme/" + themeSel.value) }
				sizeSel.onchange = function () {
					var size = parseFloat(sizeSel.value);
					if (!isNaN(size) && size >= 9 && size <= 40) {
						editor.setFontSize(size);
					}
					sizeSel.value = parseFloat(editor.getFontSize()).toFixed(1);
				}
				
				const monofonts = ["Courier New","Monaco","Lucida Console","Monospace","ui-monospace","Roboto Mono","Inconsolata","IBM Plex Mono","Space Mono","PT Mono","Ubuntu Mono","Nanum Gothic Coding",
				"Cousine","Fira Mono","Share Tech Mono","Courier Prime","Anonymous Pro","Cutive Mono","Overpass Mono","Fira Code","VT323","DM Mono","Oxygen Mono",
				"Nova Mono","B612 Mono","Spline Sans Mono","Noto Sans Mono","Major Mono Display","Azeret Mono","Red Hat Mono","Syne Mono","Xanh Mono"];
				monofonts.sort().forEach(addFont);

				function updateCutCopy() {
				  let state = !isShown || editor.session.getSelection().isEmpty();
					cutBtn.disabled = state;
					copyBtn.disabled = state;
				}
				function updateToolbar() {
				  let undo = editor.session.getUndoManager();
					saveBtn.disabled = !isShown || undo.isClean();
					undoBtn.disabled = !isShown || !undo.hasUndo();
					redoBtn.disabled = !isShown || !undo.hasRedo();
					//updateCutCopy();
				}
				saveBtn !== null && undoBtn !== null && redoBtn !== null && editor.on("input", updateToolbar);
				editor.session.selection.on("changeCursor", updateCutCopy);

				function getData(edtr) {
					var data = edtr.getValue();
					try {
						var json = JSON.parse(data);
						return JSON.stringify(json)
					} catch (error) {
						return data + ""
					}
				}

				function save() {
				    const d = getData(editor);
            const data = new FormData;
            data.append("data", new Blob([d], {
                type: mime
            }), path);

            fetch('/edit', {
                method: "POST",
                body: data
            })
  					.then((response) => {
							if (response.ok) {
                return response.text().then(text => { console.log('Save OK /edit ' + text); })                
							}
							return response.text().then(text => { console.log('Save FAIL /edit'); throw new Error(text) })                
						})
						.then((data) => {
               console.log(data);
						}) 
						.catch((error) => {
							console.warn(error.name === "AbortError" ? "Promise Aborted" : "Promise Rejected");
							alert(error);
						})
						.finally(() => {
							updateToolbar();   
						});
				}
				function paste() {
					try {
						navigator.clipboard.readText()
						.then((text) => {
							editor.execCommand("paste", text)
						})
						.catch((error) => {
							pasteBtn.disabled = true;
						})
					}
					catch {
						pasteBtn.disabled = true;
					}
				}
				function copyToClipboard() {
					var text = editor.getCopyText();
					if (window.clipboardData && window.clipboardData.setData) {
						// Internet Explorer-specific code path to prevent textarea being shown while dialog is visible.
						return window.clipboardData.setData("Text", text);
					}
					else if (document.queryCommandSupported && document.queryCommandSupported("copy")) {
						editor.focus();
						try {
							return document.execCommand("copy");  // Security exception may be thrown by some browsers.
						}
						catch (ex) {
							console.warn("Copy to clipboard failed.", ex);
							return prompt("Copy to clipboard: Ctrl+C, Enter", text);
						}
					}
				}
				
				saveBtn.onclick = save;
				undoBtn.onclick = (e)=>{editor.undo() && editor.focus()}
				redoBtn.onclick = (e)=>{editor.redo() && editor.focus()}
				cutBtn.onclick = (e)=>{copyToClipboard() && editor.execCommand("cut")};
				copyBtn.onclick = (e)=>{copyToClipboard() && editor.execCommand("copy")};
				pasteBtn.onclick = paste;
				
				function openfile(filename) {
				  _("name").innerHTML = filename;
					res = fetch(filename)
						.then((response) => {
							if (response.ok) { console.log('OK '+filename); return response.text() }
							return response.text().then(text => { console.log('ERROR '+url); throw new Error(text) })                
						})
						.then((data) => {
							try {
								var json = JSON.parse(data);
								editor.setValue(JSON.stringify(json, null, 4));
								console.log('parse json OK');
							} catch (error) {
								editor.setValue(data)
								console.log('parse json FAIL');
							}
							if (_("preview") !== null) _("preview").style.display = "none";
							if (_("editor") !== null) _("editor").style.display = "block";
							isShown = true;
							editor.resize();
							updateToolbar();
						})
						.catch((error) => {
							console.log(error);
							alert(error);
						})
						.finally(() => {
							editor.resize(true),
							editor.scrollToLine(1, true, true, function() {}),
							editor.gotoLine(1, 0, true),
							editor.clearSelection(),
							editor.getSession().setUndoManager(new ace.UndoManager())
						});
				}
				editor.loadUrl = function(dirname,filename) {
					lang = texttype(path = dirname + filename),
				  mime = "text/" + lang,
					"plain" !== lang && editor.getSession().setMode("ace/mode/" + lang),
					openfile(dirname+filename)
				}

				return "plain" !== lang && editor.getSession().setMode("ace/mode/" + lang), editor.setTheme("ace/theme/" + theme), editor.$blockScrolling = 1 / 0,
				editor.commands.addCommand({
					name: "save",
					bindKey: {
						win: "Ctrl-S",
						mac: "Command-S"
					},
					exec: save,
					readOnly: false
				}), editor.commands.addCommand({
					name: "undo",
					bindKey: {
						win: "Ctrl-Z",
						mac: "Command-Z"
					},
					exec: function() { editor.undo() }
				}), editor.commands.addCommand({
					name: "redo",
					bindKey: {
						win: "Ctrl-Y",
						mac: "Command-Y"
					},
					exec: function() { editor.redo() }
				}), undefined !== path && openfile(path),
				editor.resize(),
				editor
			}
			h=createEditor("editor",undefined,undefined,undefined);

			document.addEventListener('DOMContentLoaded', function () {
				// Query the element
  			const resizer = document.getElementById('dragMe');
				const leftSide = resizer.previousElementSibling;
				const rightSide = resizer.nextElementSibling;

				// The current position of mouse
				let x = 0;
				let y = 0;
				let leftWidth = 0;

				// Handle the mousedown event
				// that's triggered when user drags the resizer
				const mouseDownHandler = function (e) {
					// Get the current mouse position
					x = e.clientX;
					y = e.clientY;
					leftWidth = leftSide.getBoundingClientRect().width;
  				// Attach the listeners to `document`
					document.addEventListener('mousemove', mouseMoveHandler);
					document.addEventListener('mouseup', mouseUpHandler);
				};

				const mouseMoveHandler = function (e) {
					// How far the mouse has been moved
					const dx = e.clientX - x;
					const dy = e.clientY - y;

					const newLeftWidth = ((leftWidth + dx) * 100) / resizer.parentNode.getBoundingClientRect().width;
					leftSide.style.width = `${newLeftWidth}%`;
					leftSide.style.right = leftSide.style.width;

					resizer.style.cursor = 'col-resize';
					document.body.style.cursor = 'col-resize';

					leftSide.style.userSelect = 'none';
					leftSide.style.pointerEvents = 'none';

					rightSide.style.userSelect = 'none';
					rightSide.style.pointerEvents = 'none';

					ace.edit("editor").resize();
				};

				const mouseUpHandler = function () {
					resizer.style.removeProperty('cursor');
					document.body.style.removeProperty('cursor');

					leftSide.style.removeProperty('user-select');
					leftSide.style.removeProperty('pointer-events');

					rightSide.style.removeProperty('user-select');
					rightSide.style.removeProperty('pointer-events');

					// Remove the handlers of `mousemove` and `mouseup`
					document.removeEventListener('mousemove', mouseMoveHandler);
					document.removeEventListener('mouseup', mouseUpHandler);
				};

				// Attach the handler
				resizer.addEventListener('mousedown', mouseDownHandler);
				resizer.addEventListener('dblclick', () => {
					var show = leftSide.style.visibility = leftSide.style.visibility === 'hidden';
					leftSide.style.visibility = show ? 'unset' : 'hidden';
					leftSide.style.position = show ? 'unset' : 'absolute';
					ace.edit("editor").resize();
				})
			});
			
      document.addEventListener('blur', function () { hidectx() });

      var uploader;
      function checkUpload() {
            4 == uploader.readyState && (200 != uploader.status ? alert("ERROR[" + uploader.status + "]: " + uploader.responseText) : showEditor())
      }
      function doUpload() {
        const q = _('upload');
        if (0 !== q.files.length) {
          (uploader = new XMLHttpRequest).onreadystatechange = checkUpload;
          var data = new FormData;
          for (let i = 0; i < q.files.length; i++) {
            data.append("data", q.files[i], q.files[i].name)
          } 
          uploader.open("POST", "/edit"), uploader.send(data)
        }
      }
      
      function isFolder(model) {
        return model.children && model.children.length
      }
      function isText(model) {
        var a = /(?:\.([^.]+))?$/.exec(model.name)[1];
        if (void 0 !== typeof a) {
            switch (a) {
                case "txt": case "cmd": case "json": case "jsonl": case "htm": case "html": case "js": case "c": case "cpp": case "css": case "svg": case "xml": return !0
            }
        }
        return !1
      }
      function isImage(model) {
        var a = /(?:\.([^.]+))?$/.exec(model.name)[1];
        if (void 0 !== typeof a) {
            switch (a) {
                case "bmp": case "png": case "jpg": case "gif": case "svg": return !0
            }
        }
        return !1
      }
      function icon(model) {
        if (isFolder(model)) { return 'dir'}
        var a = /(?:\.([^.]+))?$/.exec(model.name)[1];
        if (void 0 !== typeof a) {
          switch (a) {
              case "cmd": case "css": case "json": case "jsonl": case "html": case "zip": case "txt": return a;
              case "gz": return 'zip';
              case "htm": return 'html';
              case "js": case "c": case "cpp": case "xml": return 'file';
              case "bmp": case "png": case "svg": case "jpg": case "gif": return 'image';
          }
        }
        return 'file';
      }
      function preview(model,path) {
        if (isImage(model)) {
          const pr = _("preview");
          const ed = _("editor");
          pr.innerHTML = '<img src="'+path+model.name+'?a='+Date.now()+'"/>';
          pr.style.display = "block";
          ed.style.display = "none"
        }
      }
      function edit(model,path) {
        if (isText(model)) {
          const pr = _("preview");
          const ed = _("editor");
          ed.style.display = "block";
          pr.style.display = "none";
          ace.edit("editor").loadUrl(path, model.name)
        }
      }
      function url(model,path) {
        console.log('click ' + path + model.name);
        if (isImage(model)) {
          preview(model,path);
        } else if (isText(model)) {
          edit(model,path);
        }
      }
      function fetchData(uri,method,data) {
        fetch(uri, { method: method, body: data })
  			.then((response) => {
  				if (response.ok) {
  				  console.log(method+' OK '+uri);
  				  return response.text()
  				}
  				return response.text().then(text => { console.log(method+' FAIL '+uri); throw new Error(text) })
  			})
  			.then((data) => {
           console.log(data);
  			}) 
  			.catch((error) => {
  				console.warn(error.name === "AbortError" ? "Promise Aborted" : "Promise Rejected");
  				alert(error);
  			})
  			.finally(() => {
  			});
      }
      function download(model,path) {
        console.log('download ' + path + model.name);
        document.getElementById("download-frame").src = path + model.name + "?download=true"
      }
      function remove(model,path,li) {
        console.log('remove ' + path + model.name);
        const data = new FormData;
        data.append("path", path + model.name);
        fetchData('/edit','DELETE', data);
        li.remove();
      }
      function create(path) {
        var name = window.prompt("Create File in "+path,"");
        if (name == null || name == "" || name.includes('/')) return;
  
        const data = new FormData;
        data.append("path", path + name);     
        this.fetchData('/edit','PUT', data);
  
        fetch('/api/files/')
          .then((res) => res.json())
          .then((data) => {
            console.log(data)
          })
      }
      function ctx(e,model,path,li) {
        console.log('ctx ' + path + model+name);
        var c = _("ctx");
        c.style.display = "block";
        
        let el;
        c.getElementsByTagName("li")[0].onclick = function() { hidectx(); create(path) };

        el = c.getElementsByTagName("li")[1];
        el.onclick = function() { edit(model,path);hidectx() };
        el.style.display = isText(model) ? "block" : "none";
  
        el = c.getElementsByTagName("li")[2];
        el.onclick = function() { preview(model,path);hidectx() };
        el.style.display = isImage(model) ? "block" : "none";

        c.getElementsByTagName("li")[3].onclick = function() { download(model,path);hidectx() };
        c.getElementsByTagName("li")[4].onclick = function() { remove(model,path,li);hidectx() };
        
        var dy = document.body.scrollTop ? document.body.scrollTop : document.documentElement.scrollTop;
        var dx = document.body.scrollLeft ? document.body.scrollLeft : document.documentElement.scrollLeft;
        var x = e.clientX + dx +10;
        var y = e.clientY + dy -20;
        var ofw = c.offsetWidth;
        var ofh = c.offsetHeight;
        var doch = document.documentElement.clientHeight;
        if(y+ofh>doch) { y = doch-ofh-20}
        c.style.left = x + "px";
        c.style.top = y + "px";

        console.log(e);
        e.preventDefault();
      }

      
      function prepare() {
        listFiles(document.getElementsByClassName('sub_div')[0],null,'/');
        _("load").onclick = function(e) {
          const data = new FormData;
          data.append("load", "");     
          fetchData('/edit','PUT', data);
        }
        _("init").onclick = function(e) {
          const data = new FormData;
          data.append("init", "");     
          fetchData('/edit','PUT', data);
        }
        _("home").onclick = function(e) {
            window.location.href = "/"
        }
        _("page").onchange = function(e) {
          const data = new FormData;
          data.append("page", _('page').value);     
          fetchData('/edit','PUT', data);
        }
      }

      function listFiles(sd,div,p) {
        console.log('listFiles');
        fetch('/api/files/?dir='+p)
        .then((res) => res.json())
        .then((data) => {
          // sd.removeChild(sd.firstElementChild);
          const ul = document.createElement("ul");
          sd.appendChild(ul);

          div && (div.onclick = function(e) {
            ul.remove();
            div.onclick = function(e) {
                listFiles(sd,div,p);
            };   
            e.stopPropagation();
          });
          
          for (var i in data) {
            const obj = data[i];
            const name = obj.name;
            const path = p;
            const li = document.createElement("li");
            ul.appendChild(li);
            const div = document.createElement("div");
            li.appendChild(div);
            div.innerHTML = '<span class="fi fa-'+icon(data[i])+'" title="'+name+'"></span><span class="fn">'+name+'</span>';
      
            if (isFolder(obj)) {
              div.classList.add("bold");
              div.onclick = function(e) {
                  console.log(obj);
                  listFiles(li,div,path+obj.name+'/');
              };      
              continue;
            }
            
            div.onclick = function(e) {
                console.log(obj);
                url(obj,path);
            };      
            div.oncontextmenu = function(e) {
              console.log(obj);
              ctx(e,obj,path,li);
            };
          }
          ul.scrollIntoView()
        })
      }
		</script>
    
  </body>
</html>
